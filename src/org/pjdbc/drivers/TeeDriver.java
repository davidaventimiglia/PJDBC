package org.pjdbc.drivers;

import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;
import org.pjdbc.util.AbstractProxyConnection;
import org.pjdbc.util.AbstractProxyDriver;
import org.pjdbc.util.AbstractProxyStatement;

public class TeeDriver extends AbstractProxyDriver {
    static {try {DriverManager.registerDriver(new TeeDriver());} catch (Exception e) {throw new RuntimeException(e);}}

    private static class ObservableStatement extends AbstractProxyStatement {
	protected List<Statement> listeners = new ArrayList<Statement>();
	public ObservableStatement (Statement delegate, Connection conn) {
	    super(delegate, conn);}
	public ObservableStatement (Statement delegate, Connection conn, List<Statement> listeners) {
	    super(delegate, conn);
	    for (Statement s : listeners) addListener(s);}
	public ObservableStatement (Statement delegate, Connection conn, Statement... listeners) {
	    super(delegate, conn);
	    for (Statement s : listeners) addListener(s);}
	public boolean addListener (Statement stmt) {
	    return this.listeners.add(stmt);}
	public boolean removeListener (Statement stmt) {
	    return this.listeners.remove(stmt);}
	public void addBatch (String sql) throws SQLException {
	    for (Statement s : listeners) s.addBatch(sql);
	    getDelegate().addBatch(sql);}
	public void cancel () throws SQLException {
	    for (Statement s : listeners) s.cancel();
	    getDelegate().cancel();}
	public void clearBatch () throws SQLException {
	    for (Statement s : listeners) s.clearBatch();
	    getDelegate().clearBatch();}
	public void clearWarnings () throws SQLException {
	    for (Statement s : listeners) s.clearWarnings();
	    getDelegate().clearWarnings();}
	public void close () throws SQLException {
	    for (Statement s : listeners) s.close();
	    getDelegate().close();}
	public void closeOnCompletion () throws SQLException {
	    for (Statement s : listeners) s.closeOnCompletion();
	    getDelegate().closeOnCompletion();}
	public void setCursorName (String name) throws SQLException {
	    for (Statement s : listeners) s.setCursorName(name);
	    getDelegate().setCursorName(name);}
	public void setEscapeProcessing (boolean enable) throws SQLException {
	    for (Statement s : listeners) s.setEscapeProcessing(enable);
	    getDelegate().setEscapeProcessing(enable);}
	public void setFetchDirection (int direction) throws SQLException {
	    for (Statement s : listeners) s.setFetchDirection(direction);
	    getDelegate().setFetchDirection(direction);}
	public void setFetchSize (int rows) throws SQLException {
	    for (Statement s : listeners) s.setFetchSize(rows);
	    getDelegate().setFetchSize(rows);}
	public void setMaxFieldSize (int max) throws SQLException {
	    for (Statement s : listeners) s.setMaxFieldSize(max);
	    getDelegate().setMaxFieldSize(max);}
	public void setMaxRows (int max) throws SQLException {
	    for (Statement s : listeners) s.setMaxRows(max);
	    getDelegate().setMaxRows(max);}
	public void setPoolable (boolean poolable) throws SQLException {
	    for (Statement s : listeners) s.setPoolable(poolable);
	    getDelegate().setPoolable(poolable);}
	public void setQueryTimeout (int seconds) throws SQLException {
	    for (Statement s : listeners) s.setQueryTimeout(seconds);
	    getDelegate().setQueryTimeout(seconds);}
	public boolean execute (String sql) throws SQLException {
	    for (Statement s : listeners) s.execute(sql);
	    return getDelegate().execute(sql);}
	public boolean execute (String sql, String[] columnNames) throws SQLException {
	    for (Statement s : listeners) s.execute(sql, columnNames);
	    return getDelegate().execute(sql, columnNames);}
	public boolean execute (String sql, int autoGeneratedKeys) throws SQLException {
	    for (Statement s : listeners) s.execute(sql, autoGeneratedKeys);
	    return getDelegate().execute(sql, autoGeneratedKeys);}
	public boolean execute (String sql, int[] columnIndexes) throws SQLException {
	    for (Statement s : listeners) s.execute(sql, columnIndexes);
	    return getDelegate().execute(sql, columnIndexes);}
	public int executeUpdate (String sql) throws SQLException {
	    for (Statement s : listeners) s.executeUpdate(sql);
	    return getDelegate().executeUpdate(sql);}
	public int executeUpdate (String sql, String[] columnNames) throws SQLException {
	    for (Statement s : listeners) s.executeUpdate(sql, columnNames);
	    return getDelegate().executeUpdate(sql, columnNames);}
	public int executeUpdate (String sql, int autoGeneratedKeys) throws SQLException {
	    for (Statement s : listeners) s.executeUpdate(sql, autoGeneratedKeys);
	    return getDelegate().executeUpdate(sql, autoGeneratedKeys);}
	public int executeUpdate (String sql, int[] columnIndexes) throws SQLException {
	    for (Statement s : listeners) s.executeUpdate(sql, columnIndexes);
	    return getDelegate().executeUpdate(sql, columnIndexes);}
	public int[] executeBatch () throws SQLException {
	    for (Statement s : listeners) s.executeBatch();
	    return getDelegate().executeBatch();}}

    private static class ObservableConnection extends AbstractProxyConnection {
	protected List<Connection> listeners = new ArrayList<Connection>();
	public ObservableConnection (Connection delegate, Driver driver, String url, Properties info) 
	    throws SQLException {
	    super(delegate, driver, url, info);}
	public ObservableConnection (Connection delegate, Driver driver, String url, Properties info, List<Connection> listeners) 
	    throws SQLException {
	    super(delegate, driver, url, info);
	    for (Connection s : listeners) addListener(s);}
	public ObservableConnection (Connection delegate, Driver driver, String url, Properties info, Connection... listeners) 
	    throws SQLException {
	    super(delegate, driver, url, info);
	    for (Connection s : listeners) addListener(s);}
	public boolean addListener (Connection conn) 
	    throws SQLException {
	    return this.listeners.add(conn);}
	public boolean removeListener (Connection conn) 
	    throws SQLException {
	    return this.listeners.remove(conn);}
	public void abort (Executor executor) 
	    throws SQLException {
	    for (Connection c : listeners) c.abort(executor);
	    getDelegate().abort(executor);}
	public void clearWarnings () 
	    throws SQLException {
	    for (Connection c : listeners) c.clearWarnings();
	    getDelegate().clearWarnings();}
	public void close () 
	    throws SQLException {
	    for (Connection c : listeners) c.close();
	    getDelegate().close();}
	public void commit () 
	    throws SQLException {
	    for (Connection c : listeners) c.commit();
	    getDelegate().commit();}
	public void releaseSavepoint (Savepoint savepoint) 
	    throws SQLException {
	    for (Connection c : listeners) c.releaseSavepoint(savepoint);
	    getDelegate().releaseSavepoint(savepoint);}
	public void rollback () 
	    throws SQLException {
	    for (Connection c : listeners) c.rollback();
	    getDelegate().rollback();}
	public void rollback (Savepoint savepoint) 
	    throws SQLException {
	    for (Connection c : listeners) c.rollback(savepoint);
	    getDelegate().rollback(savepoint);}
	public void setAutoCommit (boolean autoCommit) 
	    throws SQLException {
	    for (Connection c : listeners) c.setAutoCommit(autoCommit);
	    getDelegate().setAutoCommit(autoCommit);}
	public void setCatalog (String catalog) 
	    throws SQLException {
	    for (Connection c : listeners) c.setCatalog(catalog);
	    getDelegate().setCatalog(catalog);}
	public void setClientInfo (Properties properties) 
	    throws SQLClientInfoException {
	    for (Connection c : listeners) c.setClientInfo(properties);
	    getDelegate().setClientInfo(properties);}
	public void setClientInfo (String name, String value) 
	    throws SQLClientInfoException {
	    for (Connection c : listeners) c.setClientInfo(name, value);
	    getDelegate().setClientInfo(name, value);}
	public void setHoldability (int holdability) 
	    throws SQLException {
	    for (Connection c : listeners) c.setHoldability(holdability);
	    getDelegate().setHoldability(holdability);}
	public void setNetworkTimeout (Executor executor, int milliseconds) 
	    throws SQLException {
	    for (Connection c : listeners) c.setNetworkTimeout(executor, milliseconds);
	    getDelegate().setNetworkTimeout(executor, milliseconds);}
	public void setReadOnly (boolean readOnly) 
	    throws SQLException {
	    for (Connection c : listeners) c.setReadOnly(readOnly);
	    getDelegate().setReadOnly(readOnly);}
	public void setSchema (String schema) 
	    throws SQLException {
	    for (Connection c : listeners) c.setSchema(schema);
	    getDelegate().setSchema(schema);}
	public void setTransactionIsolation (int level) 
	    throws SQLException {
	    for (Connection c : listeners) c.setTransactionIsolation(level);
	    getDelegate().setTransactionIsolation(level);}
	public void setTypeMap (Map<String,Class<?>> map) 
	    throws SQLException {
	    for (Connection c : listeners) c.setTypeMap(map);
	    getDelegate().setTypeMap(map);}
	public Statement createStatement () 
	    throws SQLException {
	    return new ObservableStatement(getDelegate().createStatement(), this){};}
	public Statement createStatement (int resultSetType, int resultSetConcurrency) 
	    throws SQLException {
	    return new ObservableStatement(getDelegate().createStatement(resultSetType, resultSetConcurrency), this){};}
	public Statement createStatement (int resultSetType, int resultSetConcurrency, int resultSetHoldability) 
	    throws SQLException {
	    return new ObservableStatement(getDelegate().createStatement(resultSetType, resultSetConcurrency, resultSetHoldability), this){};}}
    
    protected boolean acceptsSubName (String subname) {
	try{for (String url : subname.split(";")) if (DriverManager.getDriver(subname)==null) return false;} catch (Exception e) {return false;}
	return true;}

    protected boolean acceptsSubProtocol (String subprotocol) {
	return "tee".equals(subprotocol);}

    protected Connection proxyConnection (Connection delegate, String url, Properties info, List<Connection> listeners) throws SQLException {
	ObservableConnection conn = new ObservableConnection(delegate, this, url, info);
	for (Connection c : listeners) conn.addListener(c);
	return conn;}

    public Connection connect (String url, Properties info) throws SQLException {
    	if (!acceptsURL(url)) return null;
	List<String> urls = Arrays.asList(subname(url).split(";"));
	List<Connection> listeners = new ArrayList<Connection>();
	Connection delegate = DriverManager.getConnection(urls.remove(0), info);
	for (String s : urls) listeners.add(DriverManager.getConnection(s, info));
	return proxyConnection(delegate, urls.get(0), info);}}


